#!/bin/bash

# Загружаем переменные из .env
set -o allexport
source ./.env
set +o allexport

# Проверяем наличие обязательных переменных
: "${DB_USER?Need to set DB_USER}"
: "${DB_PASSWORD?Need to set DB_PASSWORD}"
: "${DB_HOST?Need to set DB_HOST}"
: "${DB_PORT?Need to set DB_PORT}"
: "${DB_NAME?Need to set DB_NAME}"
: "${DB_SSLMODE:=disable}"

rm -f migrations/fill_db.sql

# --- Аргументы ---
usage() {
  echo "Usage: $0 [local] [docker] [go] [flutter] [database] [build] [fill] [clear]"
  echo
  echo "Key descriptions:"
  echo "  go               - Setup Go backend environment (DB migration, dependencies)"
  echo "  flutter          - Setup Flutter frontend environment (dependencies)"
  echo "  build            - Build and archive the project (use with 'go' or 'flutter'). Example: './install go build'"
  echo "  go-docker        - Build and setup Go backend in Docker"
  echo "  flutter-docker   - Build and setup Flutter frontend in Docker"
  echo "  local            - Local build of Go and Flutter"
  echo "  docker           - Build Go and Flutter in Docker"
  echo "  database         - Manage database using psql"
  echo "  fill             - Recreate and fill the database with test data (used with 'go' or 'database')"
  echo "  clear            - Clear (recreate) the database (used with 'go' or 'database')"
  exit 1
}

if [[ $# -eq 0 ]]; then
  usage
fi
GO_MODE=""
FLUTTER_MODE=""
FLUTTER_DOCKER_MODE=""
GO_DOCKER_MODE=""
DATABASE_MODE=""
FILL=""
CLEAR_MODE=""
BUILD_MODE=""
for arg in "$@"; do
  case $arg in
    go)
      GO_MODE="true"
      ;;
    go-docker)
      GO_DOCKER_MODE="true"
      ;;
    flutter)
      FLUTTER_MODE="true"
      ;;
    flutter-docker)
      FLUTTER_DOCKER_MODE="true"
      ;;
    database)
      DATABASE_MODE="true"
      ;;
    fill)
      FILL="true"
      CLEAR_MODE="true" # fill теперь также подразумевает очистку
      ;;
    clear)
      CLEAR_MODE="true"
      ;;
    build)
      BUILD_MODE="true"
      ;;
    local)
      GO_MODE="true"
      FLUTTER_MODE="true"
      ;;
    docker)
      GO_DOCKER_MODE="true"
      FLUTTER_DOCKER_MODE="true"
      ;;
    *)
      usage
      ;;
  esac
done

if [[ "$DATABASE_MODE" == "true" ]]; then
    echo "--- Database Setup using psql ---"
    export PGPASSWORD="$DB_PASSWORD"
    export PGCLIENTENCODING="UTF8"
    if [[ "$CLEAR_MODE" == "true" ]]; then
      # Удаляем базу данных, если указан флаг clear или fill
      echo "Dropping database '$DB_NAME' due to 'clear' or 'fill' flag..."
      if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -h "$DB_HOST" -p "$DB_PORT" -d "postgres" -c "DROP DATABASE IF EXISTS \"$DB_NAME\";"; then
          echo "Database '$DB_NAME' dropped successfully."
      else
          echo "Failed to drop database '$DB_NAME'."
          exit 1
      fi
    fi

    # Проверяем, существует ли база данных
    echo "Checking if database '$DB_NAME' exists..."
    if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -h "$DB_HOST" -p "$DB_PORT" -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
        echo "Database '$DB_NAME' already exists."
    else
        # Создаем базу данных, если она не существует
        echo "Database '$DB_NAME' does not exist. Creating..."
        if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -h "$DB_HOST" -p "$DB_PORT" -d "postgres" -c "CREATE DATABASE \"$DB_NAME\""; then
            echo "Database '$DB_NAME' created successfully."
        else
            echo "Failed to create database '$DB_NAME'."
            exit 1
        fi
    fi

    # Применяем все .up.sql миграции
    echo "Applying all .up.sql migrations using psql..."
    MIGRATION_FILES=$(find ./migrations -name '*.up.sql' | sort)
    if [ -z "$MIGRATION_FILES" ]; then
        echo "No .up.sql migration files found."
    else
        for file in $MIGRATION_FILES; do
            echo "Applying migration '$file'..."
            if ! PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -p "$DB_PORT" -f "$file"; then
                echo "Failed to apply migration '$file'."
                exit 1
            fi
        done
        echo "All migrations applied successfully."
    fi

    # Заполняем базу тестовыми данными, если указан флаг `fill`
    if [[ "$FILL" == "true" ]]; then
        if [ -f "fill_db.sql" ]; then
            echo "Filling database with test data from fill_db.sql..."
            # Устанавливаем переменные окружения для psql
            if ! psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -p "$DB_PORT" -f "fill_db.sql"; then
                echo "Failed to fill database from fill_db.sql."
                exit 1
            else
                echo "Database filled successfully."
            fi
        else
            echo "Warning: 'fill_db.sql' not found, skipping data filling."
        fi
    fi

    echo "--- psql Database Setup Complete ---"
fi


if [[ "$GO_MODE" == "true" ]]; then
  echo "--- Go Backend Setup ---"
  if [[ "$CLEAR_MODE" == "true" ]]; then
    # Удаляем базу данных
    echo "Dropping database '$DB_NAME'..."
    if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -h "$DB_HOST" -p "$DB_PORT" -d postgres -c "DROP DATABASE IF EXISTS \"$DB_NAME\";"; then
        echo "Database '$DB_NAME' dropped successfully."
    else
        echo "Failed to drop database '$DB_NAME'."
        exit 1
    fi
  fi

  echo "Checking if database '$DB_NAME' exists..."
  # Пытаемся подключиться к БД для проверки
  if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -h "$DB_HOST" -p "$DB_PORT" -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
      echo "Database '$DB_NAME' already exists."
  else
      echo "Database '$DB_NAME' does not exist. Creating..."
      if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -h "$DB_HOST" -p "$DB_PORT" -d postgres -c "CREATE DATABASE \"$DB_NAME\""; then
          echo "Database '$DB_NAME' created successfully."
      else
          echo "Failed to create database '$DB_NAME'."
          exit 1
      fi
  fi

  # Устанавливаем migrate, если ее нет или обновляем до последней версии
  echo "Installing/updating migrate CLI tool..."
  if go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest; then
    echo "migrate CLI installed/updated successfully."
  else
    echo "Failed to install migrate CLI. Make sure Go is installed and configured correctly."
    exit 1
  fi

  # Проверяем, доступна ли команда migrate
  if ! command -v migrate &> /dev/null
  then
      echo "'migrate' command could not be found."
      echo "Please ensure $(go env GOPATH)/bin or $HOME/go/bin is in your PATH."
      exit 1
  fi

  # Применяем миграции
  echo "Running database migrations..."
  DATABASE_URL="postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=${DB_SSLMODE}"

  if migrate -path "./migrations" -database "${DATABASE_URL}" up; then
    echo "Migrations applied successfully."
  else
    echo "Failed to apply migrations."
    exit 1
  fi

  if [[ "$FILL" == "true" ]]; then
    echo "Filling database from fill_db.sql..."
    export PGPASSWORD="$DB_PASSWORD"
    export PGCLIENTENCODING="UTF8"
    if ! psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -p "$DB_PORT" -f fill_db.sql; then
      echo "Failed to fill database from fill_db.sql."
      exit 1
    fi
  fi

  # Устанавливаем модули проекта
  echo "Downloading Go modules..."
  if go mod download; then
    echo "Go modules downloaded successfully."
  else
    echo "Failed to download Go modules."
    exit 1
  fi
  echo "Tidying Go modules..."
  if go mod tidy; then
    echo "Go modules tidied successfully."
  else
    echo "Failed to tidy Go modules."
    exit 1
  fi

  # Обновление документации
  echo "Updating Swagger documentation..."
  if ! go install github.com/swaggo/swag/cmd/swag@latest; then
    echo "Failed to update Swagger documentation."
    exit 1
  fi
  if ! swag init --dir ./cmd,./internal --output ./docs; then
    echo "Failed to update Swagger documentation."
    exit 1
  fi

  # Блок сборки, который выполняется только при наличии флага 'build'
  if [[ "$BUILD_MODE" == "true" ]]; then
    echo "--- Building Go Application ---"
    # Создаем чистую директорию для сборок
    echo "Creating build directory..."
    rm -rf ./build
    mkdir -p ./build

    # Целевые платформы для кросс-компиляции
    TARGET_PLATFORMS="linux/amd64 windows/amd64 darwin/amd64"

    echo "Building Go application for Linux, Windows, and macOS..."

    for target in $TARGET_PLATFORMS; do
      GOOS=${target%/*}
      GOARCH=${target#*/}
      
      BINARY_NAME="${GOOS}-${GOARCH}"
      if [[ "$GOOS" == "windows" ]]; then
        BINARY_NAME+=".exe"
      fi
      OUTPUT_PATH="./build/$BINARY_NAME"

      echo "--- Building for $GOOS/$GOARCH ---"
      
      if CGO_ENABLED=0 GOOS=$GOOS GOARCH=$GOARCH go build -o "$OUTPUT_PATH" cmd/main.go; then
        echo "Build successful. Binary: $OUTPUT_PATH"
        
        # Даем права на исполнение для Linux и macOS
        if [[ "$GOOS" == "linux" || "$GOOS" == "darwin" ]]; then
          echo "Making the binary executable..."
          if ! chmod +x "$OUTPUT_PATH"; then
            echo "Failed to make binary executable."
            exit 1
          fi
        fi
      else
        echo "Build for $GOOS/$GOARCH failed."
        exit 1
      fi
    done

    echo "-------------------------------------"
    echo "All Go builds completed successfully."

    # --- архивация ---
    echo "Archiving all builds into a single archive..."
    GO_ARCHIVE_NAME="backend_build.zip"
    
    if [ ! -f ".env.example" ]; then
        echo "Error: .env.example not found. Cannot create archive."
        exit 1
    fi

    # Создаем временную папку для файлов архива
    BUILD_DIR="backend_build"
    rm -rf "$BUILD_DIR"
    mkdir "$BUILD_DIR"

    # Копируем необходимые файлы
    cp ./build/* "$BUILD_DIR/"
    cp -r docs "$BUILD_DIR/"
    cp -r assets "$BUILD_DIR/"
    cp .env.example "$BUILD_DIR/.env"
    cp -r migrations "$BUILD_DIR/"
    if [ -f "fill_db.sql" ]; then
      cp fill_db.sql "$BUILD_DIR/"
    fi
    cp install "$BUILD_DIR/"


    # Удаляем старый архив
    rm -f "$GO_ARCHIVE_NAME"

    # Определяем ОС и используем соответствующую команду для архивации
    OS_TYPE="$(uname -s)"
    case "$OS_TYPE" in
      Linux*|Darwin*)
        echo "Using 'zip' command for Linux/macOS..."
        if (cd "$BUILD_DIR" && zip -r "../$GO_ARCHIVE_NAME" .); then
          echo "Go builds successfully archived to '$GO_ARCHIVE_NAME'."
        else
          echo "Failed to archive the Go builds using 'zip'."
          rm -rf "$BUILD_DIR"
          exit 1
        fi
        ;;
      CYGWIN*|MINGW*|MSYS*|Windows_NT)
        echo "Using 'PowerShell' for Windows..."
        if powershell.exe -Command "Compress-Archive -Path '$BUILD_DIR\*' -DestinationPath '$GO_ARCHIVE_NAME' -Force"; then
          echo "Go builds successfully archived to '$GO_ARCHIVE_NAME'."
        else
          echo "Failed to archive the Go builds using PowerShell."
          rm -rf "$BUILD_DIR"
          exit 1
        fi
        ;;
      *)
        echo "Unsupported OS for archiving: $OS_TYPE. Cannot create archive."
        rm -rf "$BUILD_DIR"
        exit 1
        ;;
    esac

    # Удаляем временную папку и папку сборок
    rm -rf "$BUILD_DIR"
    rm -rf "./build"
  fi # конец блока if BUILD_MODE

  echo "Go setup complete."
fi

if [[ "$GO_DOCKER_MODE" == "true" ]]; then
  if ! docker info > /dev/null 2>&1; then
    echo "Make sure that Docker Engine is running. Try restarting Docker Desktop."
    exit 1
  fi
  docker compose down > /dev/null 2>&1
  if [[ "$CLEAR_MODE" == "true" ]]; then
    docker compose down > /dev/null 2>&1
    docker volume rm electronicqueue_db-data > /dev/null 2>&1
  fi
  if [[ "$FILL" == "true" ]]; then
    echo "Copying fill_db.sql to migrations/ for Docker..."
    if ! cp fill_db.sql migrations/; then
      echo "Failed to copy fill_db.sql to migrations/."
      exit 1
    fi
  fi
  echo "Running Docker Compose build..."
  if ! docker compose build; then
    echo "Docker Compose build failed."
    [[ "$FILL" == "true" ]] && rm -f migrations/fill_db.sql
    exit 1
  fi
  echo "Running Docker Compose migrations..."
  if ! docker compose up -d db; then
    echo "migrations failed."
    [[ "$FILL" == "true" ]] && rm -f migrations/fill_db.sql
    exit 1
  fi
  echo "Waiting for database to be ready..."
  docker compose exec db pg_isready -U ${DB_USER} -d ${DB_NAME}
  
  echo "Database is ready. Migrations applied automatically."
  docker compose down > /dev/null 2>&1

  rm -f migrations/fill_db.sql
  echo "Go Docker setup complete."
fi

if [[ "$FLUTTER_MODE" == "true" ]]; then
  echo "--- Flutter Frontend Setup ---"
  cd "$(dirname "$0")/../electronicqueue-frontend" || { echo "Failed to change directory to electronicqueue-frontend."; exit 1; }
  
  # Generate .env for Flutter frontend
  FLUTTER_ENV_FILE=".env"
  echo "API_BASE_URL=${API_BASE_URL}" > "$FLUTTER_ENV_FILE"
  echo "EXTERNAL_API_KEY=${EXTERNAL_API_KEY}" >> "$FLUTTER_ENV_FILE"
  echo "INTERNAL_API_KEY=${INTERNAL_API_KEY}" >> "$FLUTTER_ENV_FILE"
  echo ".env file for Flutter frontend generated."
  echo "Getting Flutter packages..."
  if ! flutter pub get; then
    echo "Failed to fetch packages."
    exit 1
  fi

  # Блок сборки, который выполняется только при наличии флага 'build'
  if [[ "$BUILD_MODE" == "true" ]]; then
    echo "--- Building Flutter Application ---"
    if [ -z "$FRONTEND_PORT" ]; then
      echo "FRONTEND_PORT is not set in .env! Please set it to a starting port, e.g., 8080."
      exit 1
    fi

    mapfile -t FLUTTER_MAIN_FILES < <(find ./lib -maxdepth 2 -type f -name '*main*.dart' | sed 's|^\./lib/||')
    echo "Found ${#FLUTTER_MAIN_FILES[@]} main files to build and run."
    rm -rf "build/web/"

    for MAIN_FILE in "${FLUTTER_MAIN_FILES[@]}"; do
      BASE_HREF_PATH=$(basename "$MAIN_FILE" .dart | sed 's/^main_//')
      BASE_HREF_VALUE="/${BASE_HREF_PATH}/"
      OUTPUT_DIR="build/web/$BASE_HREF_PATH"

      echo "--- Building application '$BASE_HREF_PATH' from 'lib/$MAIN_FILE' ---"
      echo "    Using base href: '$BASE_HREF_VALUE'"
      echo "    Output directory: '$OUTPUT_DIR'"
      
      if ! MSYS_NO_PATHCONV=1 flutter build web --release -t "lib/$MAIN_FILE" --output "$OUTPUT_DIR" --base-href="$BASE_HREF_VALUE"; then
        echo "Failed to build '$BASE_HREF_PATH'."
        exit 1
      fi
      echo "Build for '$BASE_HREF_PATH' successful."
    done

    echo "----------------------------------------------------"
    echo "Archiving the build..."
    ARCHIVE_NAME="frontend_build.zip"
    ARCHIVE_PATH="./$ARCHIVE_NAME"
    rm -f "$ARCHIVE_PATH"

    OS_TYPE="$(uname -s)"
    case "$OS_TYPE" in
      Linux*|Darwin*)
        echo "Using 'zip' command for Linux/macOS..."
        if (cd build/web && zip -r "../../$ARCHIVE_NAME" .); then
          echo "Build successfully archived to '$ARCHIVE_NAME' in the frontend root."
        else
          echo "Failed to archive the build using 'zip'."
          exit 1
        fi
        ;;
      CYGWIN*|MINGW*|MSYS*|Windows_NT)
        echo "Using 'PowerShell' for Windows..."
        if powershell.exe -Command "Compress-Archive -Path 'build/web\*' -DestinationPath '$ARCHIVE_PATH' -Force"; then
          echo "Build successfully archived to '$ARCHIVE_NAME' in the frontend root."
        else
          echo "Failed to archive the build using PowerShell. Make sure PowerShell is available."
          exit 1
        fi
        ;;
      *)
        echo "Unsupported OS: $OS_TYPE. Cannot create archive."
        exit 1
        ;;
    esac
  fi # конец блока if BUILD_MODE

  cd - > /dev/null
  echo "Flutter setup complete."
fi

if [[ "$FLUTTER_DOCKER_MODE" == "true" ]]; then
  cd "$(dirname "$0")/../electronicqueue-frontend" || { echo "Failed to change directory to electronicqueue-frontend."; exit 1; }
  if ! docker info > /dev/null 2>&1; then
    echo "Make sure that Docker Engine is running. Try restarting Docker Desktop."
    exit 1
  fi
  docker compose down > /dev/null 2>&1
  cd "$(dirname "$0")/../electronicqueue-frontend/lib" || { echo "lib directory not found!"; exit 1; }
  mapfile -t FLUTTER_MAIN_FILES < <(find . -maxdepth 2 -mindepth 2 -type f -name '*main*.dart' | sed 's|^./||')
  cd - > /dev/null 2>&1
  FLUTTER_ENV_FILE=".env"
  API_BASE_URL="http://localhost:${BACKEND_PORT}"
  echo "API_BASE_URL=${API_BASE_URL}" > "$FLUTTER_ENV_FILE"
  echo "EXTERNAL_API_KEY=${EXTERNAL_API_KEY}" >> "$FLUTTER_ENV_FILE"
  echo "INTERNAL_API_KEY=${INTERNAL_API_KEY}" >> "$FLUTTER_ENV_FILE"
  echo ".env file for Flutter frontend generated."
  rm -f Dockerfile
  cat > Dockerfile <<EOF
FROM ghcr.io/cirruslabs/flutter:3.32.5 AS build

WORKDIR /app
COPY pubspec.yaml ./
RUN flutter pub get
COPY . .

ARG TARGET_MAIN
ARG BASE_HREF_VALUE # Добавляем аргумент для base_href
RUN flutter build web --release -t lib/\${TARGET_MAIN} --base-href=\${BASE_HREF_VALUE}

FROM nginx:alpine
COPY --from=build /app/build/web /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
EOF
  if [ -z "$FRONTEND_PORT" ]; then
    echo "FRONTEND_PORT is not set in .env!"
    exit 1
  fi
  COMPOSE_FILE="compose.yaml"
  rm -f $COMPOSE_FILE
  echo "services:" >> $COMPOSE_FILE
  INDEX=0
  for MAIN_FILE in "${FLUTTER_MAIN_FILES[@]}"; do
    SERVICE_NAME=$(basename "$MAIN_FILE" .dart | tr '[:upper:]' '[:lower:]')
    BASE_HREF_PATH=$(basename "$MAIN_FILE" .dart | sed 's/^main_//')
    BASE_HREF_VALUE="/${BASE_HREF_PATH}/"
    PORT=$((FRONTEND_PORT + INDEX))
    CONTAINER_NAME="electronicqueue_${SERVICE_NAME}"
    echo "  $SERVICE_NAME:" >> $COMPOSE_FILE
    echo "    build:" >> $COMPOSE_FILE
    echo "      context: ." >> $COMPOSE_FILE
    echo "      args:" >> $COMPOSE_FILE
    echo "        TARGET_MAIN: $MAIN_FILE" >> $COMPOSE_FILE
    echo "        BASE_HREF_VALUE: $BASE_HREF_VALUE"
    echo "    ports:" >> $COMPOSE_FILE
    echo "      - \"${PORT}:80\"" >> $COMPOSE_FILE
    echo "    env_file:" >> $COMPOSE_FILE
    echo "      - .env" >> $COMPOSE_FILE
    echo "    container_name: $CONTAINER_NAME" >> $COMPOSE_FILE
    echo "" >> $COMPOSE_FILE
    INDEX=$((INDEX + 1))
  done
  echo "Docker Compose file $COMPOSE_FILE generated."
  echo "Building Flutter frontend Docker containers..."
  if ! docker compose build; then
    echo "Docker Compose build failed."
    exit 1
  fi
  echo "Flutter Docker setup complete."
  cd - > /dev/null
fi

exit 0